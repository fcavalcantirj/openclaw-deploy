#!/usr/bin/env bash
# =============================================================================
# claw — Master CLI for managing OpenClaw child instances
# =============================================================================
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
INSTANCES_DIR="$SCRIPT_DIR/instances"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
BOLD='\033[1m'
NC='\033[0m'

usage() {
  cat <<EOF
${BOLD}claw — OpenClaw Child Instance Manager${NC}

${BOLD}Usage:${NC}
  claw <command> [args]

${BOLD}Commands:${NC}
  ${GREEN}deploy${NC} --name NAME --bot-token TOKEN   Deploy new child instance
  ${GREEN}list${NC}                                   List all child instances
  ${GREEN}status${NC} NAME                            Show child status
  ${GREEN}approve${NC} NAME CODE                      Approve Telegram pairing
  ${GREEN}message${NC} NAME "text"                    Send message to child
  ${GREEN}logs${NC} NAME [-f]                         View child logs (-f to follow)
  ${GREEN}restart${NC} NAME                           Restart child gateway
  ${GREEN}destroy${NC} NAME                           Destroy child instance
  ${GREEN}diagnose${NC} NAME                           Run health checks + Solvr search
  ${GREEN}fix${NC} NAME                               Fix issues via Solvr, escalate after 3 failures
  ${GREEN}ssh${NC} NAME                               SSH into child (for debugging)

${BOLD}Examples:${NC}
  claw deploy --name bruce --bot-token "123:ABC..."
  claw list
  claw approve bruce 3R7YX6KS
  claw diagnose bruce
  claw fix bruce
  claw message bruce "Hello from parent!"
  claw logs bruce -f
  claw destroy bruce

EOF
  exit 1
}

# Get instance metadata
get_meta() {
  local name="$1"
  local field="$2"
  local meta_file="$INSTANCES_DIR/$name/metadata.json"
  [[ -f "$meta_file" ]] && jq -r ".$field // empty" "$meta_file"
}

# Get SSH command for instance
ssh_cmd() {
  local name="$1"
  local key=$(get_meta "$name" "ssh_key_path")
  local ip=$(get_meta "$name" "ip")
  echo "ssh -i $key -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o LogLevel=ERROR"
}

# =============================================================================
# Commands
# =============================================================================

cmd_list() {
  echo -e "${BOLD}OpenClaw Child Instances${NC}\n"
  
  if [[ ! -d "$INSTANCES_DIR" ]] || [[ -z "$(ls -A "$INSTANCES_DIR" 2>/dev/null | grep -v credentials | grep -v .archive)" ]]; then
    echo "No instances found."
    return
  fi
  
  printf "%-20s %-16s %-25s %-10s\n" "NAME" "IP" "BOT" "STATUS"
  printf "%-20s %-16s %-25s %-10s\n" "----" "--" "---" "------"
  
  for dir in "$INSTANCES_DIR"/*/; do
    [[ -d "$dir" ]] || continue
    [[ "$(basename "$dir")" == ".archive" ]] && continue
    [[ "$(basename "$dir")" == "credentials.json" ]] && continue
    
    local name=$(basename "$dir")
    local meta="$dir/metadata.json"
    
    if [[ -f "$meta" ]]; then
      local ip=$(jq -r '.ip // "-"' "$meta")
      local bot=$(jq -r '.bot_username // "-"' "$meta")
      local status=$(jq -r '.status // "unknown"' "$meta")
      
      # Quick health check
      if ssh -i "$(jq -r '.ssh_key_path' "$meta")" -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o ConnectTimeout=3 -o LogLevel=ERROR "root@$ip" "systemctl is-active openclaw-gateway" 2>/dev/null | grep -q "active"; then
        status="${GREEN}running${NC}"
      else
        status="${RED}down${NC}"
      fi
      
      printf "%-20s %-16s %-25s %b\n" "$name" "$ip" "@$bot" "$status"
    fi
  done
}

cmd_status() {
  local name="${1:?Usage: claw status NAME}"
  local ip=$(get_meta "$name" "ip")
  local key=$(get_meta "$name" "ssh_key_path")
  
  [[ -z "$ip" ]] && { echo "Instance '$name' not found"; exit 1; }
  
  echo -e "${BOLD}Status: $name${NC} ($ip)\n"
  
  ssh -i "$key" -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o LogLevel=ERROR "root@$ip" "
    echo '=== Gateway ==='
    systemctl is-active openclaw-gateway
    
    echo ''
    echo '=== AMCP ==='
    amcp identity validate --file /home/openclaw/.amcp/identity.json --json 2>/dev/null | jq '{aid: .aid[:20], valid: .valid, status: .status}' || echo 'No AMCP'
    
    echo ''
    echo '=== Uptime ==='
    uptime
  " 2>/dev/null
}

cmd_approve() {
  local name="${1:-}"
  local code="${2:-}"
  local ip=$(get_meta "$name" "ip")
  local key=$(get_meta "$name" "ssh_key_path")
  local token=$(get_meta "$name" "gateway_token")

  [[ -z "$ip" ]] && { echo "Instance '$name' not found"; exit 1; }
  [[ -z "$code" ]] && { echo "Usage: claw approve NAME CODE"; exit 1; }

  echo -e "${BLUE}Approving pairing code $code on $name...${NC}"

  ssh -i "$key" -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o LogLevel=ERROR "root@$ip" \
    "su - openclaw -c 'OPENCLAW_GATEWAY_TOKEN=\"${token}\" openclaw pairing approve telegram ${code} 2>&1'"

  echo -e "${GREEN}✓ Approved${NC}"
}

cmd_message() {
  local name="${1:-}"
  local msg="${2:-}"
  local ip=$(get_meta "$name" "ip")
  local key=$(get_meta "$name" "ssh_key_path")
  local token=$(get_meta "$name" "gateway_token")

  [[ -z "$ip" ]] && { echo "Instance '$name' not found"; exit 1; }
  [[ -z "$msg" ]] && { echo "Usage: claw message NAME \"text\""; exit 1; }

  # Use heredoc to safely pass the message without injection risk
  ssh -i "$key" -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o LogLevel=ERROR "root@$ip" \
    "su - openclaw -c 'OPENCLAW_GATEWAY_TOKEN=\"${token}\" openclaw agent --session-id parent --message \"${msg//\"/\\\"}\" 2>&1'"
}

cmd_logs() {
  local name="${1:?Usage: claw logs NAME [-f]}"
  local follow="${2:-}"
  local ip=$(get_meta "$name" "ip")
  local key=$(get_meta "$name" "ssh_key_path")
  
  [[ -z "$ip" ]] && { echo "Instance '$name' not found"; exit 1; }
  
  if [[ "$follow" == "-f" ]]; then
    ssh -i "$key" -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o LogLevel=ERROR "root@$ip" \
      "journalctl -u openclaw-gateway -f" 2>/dev/null
  else
    ssh -i "$key" -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o LogLevel=ERROR "root@$ip" \
      "journalctl -u openclaw-gateway --no-pager -n 50" 2>/dev/null
  fi
}

cmd_restart() {
  local name="${1:?Usage: claw restart NAME}"
  local ip=$(get_meta "$name" "ip")
  local key=$(get_meta "$name" "ssh_key_path")
  
  [[ -z "$ip" ]] && { echo "Instance '$name' not found"; exit 1; }
  
  echo -e "${BLUE}Restarting $name...${NC}"
  ssh -i "$key" -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o LogLevel=ERROR "root@$ip" \
    "systemctl restart openclaw-gateway && sleep 2 && systemctl is-active openclaw-gateway" 2>/dev/null
  echo -e "${GREEN}✓ Restarted${NC}"
}

cmd_destroy() {
  local name="$1"
  [[ -z "$name" ]] && { echo "Usage: claw destroy NAME"; exit 1; }
  
  echo -e "${YELLOW}Destroying $name...${NC}"
  "$SCRIPT_DIR/scripts/destroy.sh" "$name" --confirm
}

cmd_ssh() {
  local name="${1:?Usage: claw ssh NAME}"
  local ip=$(get_meta "$name" "ip")
  local key=$(get_meta "$name" "ssh_key_path")
  
  [[ -z "$ip" ]] && { echo "Instance '$name' not found"; exit 1; }
  
  echo -e "${CYAN}Connecting to $name ($ip)...${NC}"
  ssh -i "$key" -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null "openclaw@$ip"
}

cmd_diagnose() {
  local name="${1:?Usage: claw diagnose NAME}"
  local ip=$(get_meta "$name" "ip")
  local key=$(get_meta "$name" "ssh_key_path")

  [[ -z "$ip" ]] && { echo "Instance '$name' not found"; exit 1; }

  local ssh_base="ssh -i $key -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o LogLevel=ERROR"

  echo -e "${BLUE}Diagnosing $name ($ip)...${NC}" >&2

  # Read child's Solvr API key from proactive-amcp config on the VM
  local solvr_key
  solvr_key=$($ssh_base "root@$ip" \
    "proactive-amcp config get solvr_api_key --amcp-dir /home/openclaw/.amcp 2>/dev/null || echo ''" 2>/dev/null)
  solvr_key=$(echo "$solvr_key" | tr -d '[:space:]')

  # Read Anthropic key from credentials or environment
  local credentials_file="$INSTANCES_DIR/credentials.json"
  local anthropic_key=""
  if [[ -f "$credentials_file" ]]; then
    anthropic_key=$(jq -r '.anthropic_api_key // empty' "$credentials_file")
  fi
  if [[ -z "$anthropic_key" ]]; then
    anthropic_key="${ANTHROPIC_API_KEY:-}"
  fi
  if [[ -z "$anthropic_key" ]]; then
    echo -e "${RED}No ANTHROPIC_API_KEY found in credentials or environment${NC}" >&2
    exit 1
  fi

  # Load diagnose prompt template
  local template_file="$SCRIPT_DIR/templates/diagnose-prompt.md"
  if [[ ! -f "$template_file" ]]; then
    echo -e "${RED}Template not found: $template_file${NC}" >&2
    exit 1
  fi

  # Build prompt file locally with placeholders replaced
  local prompt_tmp
  prompt_tmp=$(mktemp /tmp/claw-diagnose-XXXXXX.md)
  trap "rm -f '$prompt_tmp'" RETURN

  # Build Solvr section based on key availability
  local solvr_section_file
  solvr_section_file=$(mktemp /tmp/claw-solvr-XXXXXX.txt)
  if [[ -n "$solvr_key" && "$solvr_key" != "null" ]]; then
    cat > "$solvr_section_file" << SOLVREOF
For each failed check:
1. Search Solvr for existing solutions:
   curl -s -H "Authorization: Bearer ${solvr_key}" -G --data-urlencode "q=<error description>" "https://api.solvr.dev/v1/problems/search"
2. If a matching problem exists, include it in solvr_matches
3. If NO match found, post a new problem:
   curl -s -X POST "https://api.solvr.dev/v1/problems" -H "Authorization: Bearer ${solvr_key}" -H "Content-Type: application/json" -d '{"title": "<short title>", "description": "<error details>", "tags": ["openclaw", "gateway", "auto-diagnose"]}'
4. Include posted problems in solvr_posts
SOLVREOF
  else
    echo "No Solvr API key available. Set solvr_matches and solvr_posts to empty arrays." > "$solvr_section_file"
  fi

  # Replace placeholders: INSTANCE_NAME inline, SOLVR_SECTION via awk (multiline-safe)
  awk -v name="$name" -v solvr_file="$solvr_section_file" '
    { gsub(/\{\{INSTANCE_NAME\}\}/, name) }
    /\{\{SOLVR_SECTION\}\}/ { while ((getline line < solvr_file) > 0) print line; next }
    { print }
  ' "$template_file" > "$prompt_tmp"
  rm -f "$solvr_section_file"

  # Upload prompt to VM
  local remote_prompt="/tmp/claw-diagnose-prompt.md"
  scp -i "$key" -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o LogLevel=ERROR \
    "$prompt_tmp" "root@${ip}:${remote_prompt}" 2>/dev/null
  rm -f "$prompt_tmp"

  echo -e "${BLUE}Running Claude Code on $name...${NC}" >&2

  # Run Claude Code on the VM with the uploaded prompt, then clean up
  local result
  result=$($ssh_base -t "root@$ip" \
    "ANTHROPIC_API_KEY='${anthropic_key}' claude --print \"\$(cat ${remote_prompt})\" ; rm -f ${remote_prompt}" 2>/dev/null)

  # Strip TTY control characters (from -t flag)
  result=$(echo "$result" | tr -d '\r' | sed 's/\x1b\[[0-9;]*[a-zA-Z]//g')

  # Extract JSON from output — Claude may include surrounding text
  local json_output
  json_output=$(echo "$result" | python3 -c "
import sys, json
text = sys.stdin.read()
# Find the outermost JSON object
depth = 0
start = -1
for i, c in enumerate(text):
    if c == '{':
        if depth == 0:
            start = i
        depth += 1
    elif c == '}':
        depth -= 1
        if depth == 0 and start >= 0:
            candidate = text[start:i+1]
            try:
                obj = json.loads(candidate)
                print(json.dumps(obj))
                sys.exit(0)
            except json.JSONDecodeError:
                start = -1
print('')
" 2>/dev/null)

  if [[ -n "$json_output" ]] && echo "$json_output" | jq . >/dev/null 2>&1; then
    echo "$json_output" | jq .
  else
    # Could not parse — return raw output wrapped in error JSON
    echo -e "${YELLOW}Warning: Could not parse JSON from Claude Code output${NC}" >&2
    jq -n \
      --arg instance "$name" \
      --arg timestamp "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
      --arg raw_output "$result" \
      '{
        instance: $instance,
        timestamp: $timestamp,
        checks_passed: 0,
        checks_failed: 0,
        checks: {},
        errors: ["diagnose output was not valid JSON — see raw_output"],
        solvr_matches: [],
        solvr_posts: [],
        raw_output: $raw_output
      }'
  fi
}

cmd_fix() {
  local name="${1:?Usage: claw fix NAME}"
  local ip=$(get_meta "$name" "ip")
  local key=$(get_meta "$name" "ssh_key_path")

  [[ -z "$ip" ]] && { echo "Instance '$name' not found"; exit 1; }

  local ssh_base="ssh -i $key -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o LogLevel=ERROR"

  # Step 1: Run diagnose internally
  echo -e "${BLUE}Step 1: Running diagnosis on $name...${NC}" >&2
  local diagnose_output
  diagnose_output=$(cmd_diagnose "$name" 2>/dev/null)

  if [[ -z "$diagnose_output" ]] || ! echo "$diagnose_output" | jq . >/dev/null 2>&1; then
    echo -e "${RED}Diagnosis failed — cannot proceed with fix${NC}" >&2
    exit 1
  fi

  # Check if there are any errors to fix
  local error_count
  error_count=$(echo "$diagnose_output" | jq '.checks_failed // 0')
  if [[ "$error_count" -eq 0 ]]; then
    echo -e "${GREEN}No issues found — $name is healthy${NC}" >&2
    echo "$diagnose_output"
    return 0
  fi

  echo -e "${YELLOW}Found $error_count issue(s) — attempting fixes...${NC}" >&2

  # Step 2: Gather credentials
  local solvr_key
  solvr_key=$($ssh_base "root@$ip" \
    "proactive-amcp config get solvr_api_key --amcp-dir /home/openclaw/.amcp 2>/dev/null || echo ''" 2>/dev/null)
  solvr_key=$(echo "$solvr_key" | tr -d '[:space:]')

  local credentials_file="$INSTANCES_DIR/credentials.json"
  local anthropic_key=""
  if [[ -f "$credentials_file" ]]; then
    anthropic_key=$(jq -r '.anthropic_api_key // empty' "$credentials_file")
  fi
  if [[ -z "$anthropic_key" ]]; then
    anthropic_key="${ANTHROPIC_API_KEY:-}"
  fi
  if [[ -z "$anthropic_key" ]]; then
    echo -e "${RED}No ANTHROPIC_API_KEY found in credentials or environment${NC}" >&2
    exit 1
  fi

  # Read parent notification config from metadata
  local meta_file="$INSTANCES_DIR/$name/metadata.json"
  local parent_telegram_token parent_chat_id parent_email
  parent_telegram_token=$(jq -r '.parent_telegram_token // empty' "$meta_file" 2>/dev/null)
  parent_chat_id=$(jq -r '.parent_chat_id // empty' "$meta_file" 2>/dev/null)
  parent_email=$(jq -r '.parent_email // empty' "$meta_file" 2>/dev/null)

  # Step 3: Load fix prompt template
  local template_file="$SCRIPT_DIR/templates/fix-prompt.md"
  if [[ ! -f "$template_file" ]]; then
    echo -e "${RED}Template not found: $template_file${NC}" >&2
    exit 1
  fi

  # Step 4: Build Solvr fix section
  local solvr_fix_file
  solvr_fix_file=$(mktemp /tmp/claw-solvr-fix-XXXXXX.txt)
  if [[ -n "$solvr_key" && "$solvr_key" != "null" ]]; then
    cat > "$solvr_fix_file" << SOLVREOF
Search Solvr for existing solutions:
\`\`\`bash
curl -s -H "Authorization: Bearer ${solvr_key}" -G --data-urlencode "q=<error description>" "https://api.solvr.dev/v1/problems/search"
\`\`\`

If a matching approach exists, apply its method. After applying, update the approach status:
\`\`\`bash
# Mark as "worked" or "failed"
curl -s -X PATCH "https://api.solvr.dev/v1/approaches/<approach_id>" -H "Authorization: Bearer ${solvr_key}" -H "Content-Type: application/json" -d '{"status": "worked"}'
\`\`\`

If NO match found, post a new problem:
\`\`\`bash
curl -s -X POST "https://api.solvr.dev/v1/problems" -H "Authorization: Bearer ${solvr_key}" -H "Content-Type: application/json" -d '{"title": "<short title>", "description": "<error details>", "tags": ["openclaw", "gateway", "auto-fix"]}'
\`\`\`

After attempting a fix, add an approach to the problem:
\`\`\`bash
curl -s -X POST "https://api.solvr.dev/v1/problems/<problem_id>/approaches" -H "Authorization: Bearer ${solvr_key}" -H "Content-Type: application/json" -d '{"angle": "<what you tried>", "method": "<exact commands>", "status": "worked|failed"}'
\`\`\`
SOLVREOF
  else
    echo "No Solvr API key available. Skip all Solvr operations. Set solvr_problem_id and solvr_approach_id to null in output." > "$solvr_fix_file"
  fi

  # Step 5: Build escalation section
  local escalation_file
  escalation_file=$(mktemp /tmp/claw-escalation-XXXXXX.txt)
  local has_escalation=false
  if [[ -n "$parent_telegram_token" && -n "$parent_chat_id" ]]; then
    has_escalation=true
    cat > "$escalation_file" << ESCEOF
Send Telegram notification to parent:
\`\`\`bash
curl -s -X POST "https://api.telegram.org/bot${parent_telegram_token}/sendMessage" -H "Content-Type: application/json" -d "{\"chat_id\": \"${parent_chat_id}\", \"text\": \"ALERT: Instance ${name} has issues that could not be auto-fixed after 3 attempts.\n\nErrors:\n<list each escalated error>\n\nApproaches tried:\n<list each failed approach>\n\nPlease investigate manually: claw ssh ${name}\", \"parse_mode\": \"HTML\"}"
\`\`\`
ESCEOF
  else
    echo "No parent Telegram credentials configured. Set telegram_sent to false in escalation output." > "$escalation_file"
  fi

  if [[ -n "$parent_email" ]]; then
    cat >> "$escalation_file" << EMAILEOF

Send email notification (if mail command available):
\`\`\`bash
echo "ALERT: Instance ${name} has issues that could not be auto-fixed. Please investigate: claw ssh ${name}" | mail -s "OpenClaw Alert: ${name} needs attention" "${parent_email}" 2>/dev/null || true
\`\`\`
EMAILEOF
  else
    echo "No parent email configured. Set email_sent to false in escalation output." >> "$escalation_file"
  fi

  # Step 6: Build final prompt with all placeholders replaced
  local prompt_tmp
  prompt_tmp=$(mktemp /tmp/claw-fix-XXXXXX.md)
  trap "rm -f '$prompt_tmp' '$solvr_fix_file' '$escalation_file'" RETURN

  # Escape diagnose JSON for awk insertion
  local diagnose_file
  diagnose_file=$(mktemp /tmp/claw-diagnose-out-XXXXXX.json)
  echo "$diagnose_output" > "$diagnose_file"

  awk -v name="$name" \
      -v diagnose_f="$diagnose_file" \
      -v solvr_f="$solvr_fix_file" \
      -v esc_f="$escalation_file" '
    { gsub(/\{\{INSTANCE_NAME\}\}/, name) }
    /\{\{DIAGNOSE_OUTPUT\}\}/ { while ((getline line < diagnose_f) > 0) print line; next }
    /\{\{SOLVR_FIX_SECTION\}\}/ { while ((getline line < solvr_f) > 0) print line; next }
    /\{\{ESCALATION_SECTION\}\}/ { while ((getline line < esc_f) > 0) print line; next }
    { print }
  ' "$template_file" > "$prompt_tmp"
  rm -f "$diagnose_file" "$solvr_fix_file" "$escalation_file"

  # Step 7: Upload prompt to VM and run Claude Code
  local remote_prompt="/tmp/claw-fix-prompt.md"
  scp -i "$key" -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o LogLevel=ERROR \
    "$prompt_tmp" "root@${ip}:${remote_prompt}" 2>/dev/null

  echo -e "${BLUE}Step 2: Running Claude Code fix session on $name...${NC}" >&2

  local result
  result=$($ssh_base -t "root@$ip" \
    "ANTHROPIC_API_KEY='${anthropic_key}' claude --print \"\$(cat ${remote_prompt})\" ; rm -f ${remote_prompt}" 2>/dev/null)

  # Strip TTY control characters
  result=$(echo "$result" | tr -d '\r' | sed 's/\x1b\[[0-9;]*[a-zA-Z]//g')

  # Extract JSON from output
  local json_output
  json_output=$(echo "$result" | python3 -c "
import sys, json
text = sys.stdin.read()
depth = 0
start = -1
for i, c in enumerate(text):
    if c == '{':
        if depth == 0:
            start = i
        depth += 1
    elif c == '}':
        depth -= 1
        if depth == 0 and start >= 0:
            candidate = text[start:i+1]
            try:
                obj = json.loads(candidate)
                print(json.dumps(obj))
                sys.exit(0)
            except json.JSONDecodeError:
                start = -1
print('')
" 2>/dev/null)

  # Step 8: Process result and handle escalation/notification
  if [[ -n "$json_output" ]] && echo "$json_output" | jq . >/dev/null 2>&1; then
    local fixed_count escalated_count
    fixed_count=$(echo "$json_output" | jq '.fixed // 0')
    escalated_count=$(echo "$json_output" | jq '.escalated // 0')

    # Send calm summary to parent on success (if all fixed, no escalations)
    if [[ "$escalated_count" -eq 0 && "$fixed_count" -gt 0 && -n "$parent_telegram_token" && -n "$parent_chat_id" ]]; then
      local summary_msg="Instance ${name}: auto-fixed ${fixed_count} issue(s). All checks passing now."
      curl -s -X POST "https://api.telegram.org/bot${parent_telegram_token}/sendMessage" \
        -H "Content-Type: application/json" \
        -d "$(jq -n --arg chat_id "$parent_chat_id" --arg text "$summary_msg" '{chat_id: $chat_id, text: $text}')" \
        >/dev/null 2>&1 || true
      echo -e "${GREEN}Sent fix summary to parent Telegram${NC}" >&2
    fi

    if [[ "$escalated_count" -gt 0 ]]; then
      echo -e "${RED}$escalated_count issue(s) could not be auto-fixed and were escalated${NC}" >&2
    fi
    if [[ "$fixed_count" -gt 0 ]]; then
      echo -e "${GREEN}$fixed_count issue(s) successfully fixed${NC}" >&2
    fi

    echo "$json_output" | jq .
  else
    echo -e "${YELLOW}Warning: Could not parse JSON from Claude Code fix output${NC}" >&2
    jq -n \
      --arg instance "$name" \
      --arg timestamp "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
      --arg raw_output "$result" \
      '{
        instance: $instance,
        timestamp: $timestamp,
        total_errors: 0,
        fixed: 0,
        failed: 0,
        escalated: 0,
        fixes: [],
        escalations: [],
        raw_output: $raw_output
      }'
  fi
}

cmd_deploy() {
  "$SCRIPT_DIR/deploy.sh" "$@"
}

# =============================================================================
# Main
# =============================================================================

[[ $# -lt 1 ]] && usage

cmd="$1"
shift

case "$cmd" in
  deploy)   cmd_deploy "$@" ;;
  list)     cmd_list ;;
  status)   cmd_status "$@" ;;
  diagnose) cmd_diagnose "$@" ;;
  fix)      cmd_fix "$@" ;;
  approve)  cmd_approve "$@" ;;
  message)  cmd_message "$@" ;;
  logs)     cmd_logs "$@" ;;
  restart)  cmd_restart "$@" ;;
  destroy)  cmd_destroy "$@" ;;
  ssh)      cmd_ssh "$@" ;;
  help)     usage ;;
  *)        echo "Unknown command: $cmd"; usage ;;
esac
